<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Benji Racers</title>
  <!-- SIMPLE BASELINE vA: forked stable build -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0b0b0b;
      height: 100%;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }

    /* Overlay takes full screen and becomes the "scene" for menu/end */
    #overlay {
      position: fixed;
      inset: 0;
      display: none; /* shown by JS when needed */
      align-items: center;
      justify-content: center;
      pointer-events: none;
      padding: 18px;

      /* background art set dynamically in JS */
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    /* Dark scrim + subtle blur feel */
    #overlay::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 50% 35%, rgba(0,0,0,0.40), rgba(0,0,0,0.82));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #overlay .card {
      position: relative;          /* above scrim */
      pointer-events: auto;
      background: rgba(15,15,15,0.72);
      color: #fff;
      padding: 18px 18px 16px;
      border-radius: 18px;
      text-align: center;
      width: min(720px, 94vw);
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.10);
    }

    /* Landscape title hero image inside the card */
    .titleArt {
      width: min(620px, 92vw);
      aspect-ratio: 16 / 9;
      margin: 10px auto 12px;
      border-radius: 16px;
      overflow: hidden;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .titleArt img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .btnRow {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 14px;
    }

    /* Sleek app buttons */
    #overlay button {
      font-size: 20px;
      font-weight: 800;
      letter-spacing: 0.2px;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      cursor: pointer;
      width: 100%;
      background: rgba(255,255,255,0.92);
      color: #111;
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      transform: translateY(0);
      transition: transform 120ms ease, filter 120ms ease;
    }
    #overlay button:active {
      transform: translateY(2px);
      filter: brightness(0.95);
    }

    #hint {
      position: fixed;
      left: 12px;
      bottom: 10px;
      color: rgba(255,255,255,0.85);
      font-size: 14px;
      background: rgba(0,0,0,0.35);
      padding: 6px 10px;
      border-radius: 10px;
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
    }

    #audioHint{
      position:fixed; right:12px; bottom:10px;
      color: rgba(255,255,255,0.70);
      font-size:12px;
      background: rgba(0,0,0,0.28);
      padding:6px 10px;
      border-radius:10px;
      user-select:none;
      -webkit-user-select:none;
      pointer-events:none;
      display:none;
    }
  
/* --- Confetti (win celebration) --- */
#confettiBox { position: absolute; inset: 0; pointer-events: none; overflow: hidden; }
.confettiPiece {
  position: absolute;
  top: -10vh;
  font-size: 22px;
  animation: confettiFall 1.6s linear forwards;
  will-change: transform, opacity;
  filter: drop-shadow(0 2px 1px rgba(0,0,0,0.25));
}
@keyframes confettiFall {
  0% { transform: translate3d(var(--x, 0px), -10vh, 0) rotate(0deg); opacity: 0; }
  10% { opacity: 1; }
  100% { transform: translate3d(var(--x, 0px), 110vh, 0) rotate(540deg); opacity: 0.95; }
}

</style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="overlay">
    <div class="card" id="card"></div>
  </div>

  <div id="hint">Drag the car ‚Ä¢ Landscape works best ‚Ä¢ Add to Home Screen on iPad</div>
  <div id="audioHint">Tap once to enable sound</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const overlay = document.getElementById('overlay');
  const card = document.getElementById('card');
  const hint = document.getElementById('hint');
  const audioHint = document.getElementById('audioHint');

  // --- sizing ---
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  let W = 0, H = 0;

  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // --- load images ---
  function loadImg(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ img, ok: true });
      img.onerror = () => resolve({ img: null, ok: false });
      img.src = src;
    });
  }

  
  // ---- Audio (minimal, safe) ----
  const AUDIO_PATH = {
    engine: 'audio/engine_loop.mp3',
    boost:  'audio/boost.mp3',
    cone:   'audio/cone_hit.mp3',
    bump:   'audio/bump.mp3',
    win:    'audio/win.mp3',
    lose:   'audio/lose.mp3',
    click:  'audio/click.mp3'
  };

  const audio = {
    unlocked:false,
    engineEl:null,
    sfx:{},
    engineRate:1.0
  };

  function makeAudio(src, loop=false){
    const el = new Audio();
    el.src = src;
    el.loop = loop;
    el.preload = 'auto';
    el.playsInline = true;
    return el;
  }

  function initAudio(){
    audio.engineEl = makeAudio(AUDIO_PATH.engine, true);
    audio.engineEl.volume = 0.25;

    audio.sfx.boost = makeAudio(AUDIO_PATH.boost);
    audio.sfx.cone  = makeAudio(AUDIO_PATH.cone);
    audio.sfx.bump  = makeAudio(AUDIO_PATH.bump);
    audio.sfx.win   = makeAudio(AUDIO_PATH.win);
    audio.sfx.lose  = makeAudio(AUDIO_PATH.lose);
    audio.sfx.click = makeAudio(AUDIO_PATH.click);

    audio.sfx.boost.volume = 0.55;
    audio.sfx.cone.volume  = 0.60;
    audio.sfx.bump.volume  = 0.60;
    audio.sfx.win.volume   = 0.70;
    audio.sfx.lose.volume  = 0.65;
    audio.sfx.click.volume = 0.55;
  }

  function maybeShowAudioHint(){
    if (!audio.unlocked && audioHint) audioHint.style.display = 'block';
  }

  function unlockAudioOnce(){
    if (audio.unlocked) return;
    audio.unlocked = true;
    if (audioHint) audioHint.style.display = 'none';

    // Prime elements (iOS/Safari)
    const els = [audio.engineEl, ...Object.values(audio.sfx)];
    for (const el of els){
      if (!el) continue;
      try{
        el.muted = true;
        const p = el.play();
        if (p && p.then){
          p.then(()=>{ el.pause(); el.currentTime=0; el.muted=false; })
           .catch(()=>{ el.muted=false; });
        } else {
          el.pause(); el.currentTime=0; el.muted=false;
        }
      } catch {}
    }
  }

  function sfxPlay(name){
    if (!audio.unlocked) return;
    const el = audio.sfx[name];
    if (!el) return;
    try{
      el.pause(); el.currentTime = 0;
      el.play().catch(()=>{});
    } catch {}
  }

  function engineStart(){
    if (!audio.unlocked || !audio.engineEl) return;
    try{
      audio.engineEl.volume = 0.25;
      audio.engineEl.playbackRate = 1.0;
      audio.engineEl.play().catch(()=>{});
    } catch {}
  }
  function engineStop(){
    if (!audio.engineEl) return;
    try{ audio.engineEl.pause(); } catch {}
  }
  function engineUpdate(mph){
    if (!audio.unlocked || !audio.engineEl) return;
    const base = 0.80;
    const maxR = 1.35;
    const normalized = clamp(mph / 120, 0, 1.2);
    let target = base + normalized * 0.45;
    target = clamp(target, base, maxR);

    audio.engineRate += (target - audio.engineRate) * 0.12;
    try{ audio.engineEl.playbackRate = audio.engineRate; } catch {}

    const v = 0.18 + clamp(mph/180, 0, 1) * 0.16;
    audio.engineEl.volume = clamp(v, 0.15, 0.33);
  }

  // Unlock audio on any user gesture
  function anyGestureUnlock(){ unlockAudioOnce(); }
  window.addEventListener('mousedown', anyGestureUnlock, { passive:true });
  window.addEventListener('touchstart', anyGestureUnlock, { passive:true });

let car1 = null, car2 = null;
  let car1OK = false, car2OK = false;
  let champCar = null;
  let champCarOK = false;

  let legendCar = null;
  let legendCarOK = false;
  // Player selectable car sprites (loaded dynamically from GARAGE_CARS)
  const carSprites = Object.create(null); // id -> { img, ok }


  // --- modes ---
  const MODE = { RACE: 'race', TIME: 'time', GARAGE: 'garage', CHAMP: 'champ', LEGEND: 'legend' };

  // --- garage / car selection ---
  // Update these filenames to match your assets.
  // Sprites: used in-game for the player car.
  // Heroes: used in the Garage screen as a big display image.
  const GARAGE_CARS = [
    { id: 'red',     name: 'The Red Car',     sprite: 'assets/car_red.png',     hero: 'assets/garage_red.png' },
    { id: 'blue',    name: 'Blue Mama',    sprite: 'assets/car_blue.png',    hero: 'assets/garage_blue.png' },
    { id: 'pink',    name: 'Pink Dad',    sprite: 'assets/car_pink.png',    hero: 'assets/garage_pink.png' },
    { id: 'green',   name: 'Benji Monster',   sprite: 'assets/car_green.png',   hero: 'assets/garage_green.png' },
    { id: 'mystery', name: 'Mystery Hannah', sprite: 'assets/car_mystery.png', hero: 'assets/garage_mystery.png' },
  ];

  // Optional unlock gate (set to 0 to always unlock):
  // Example: 110 means Garage unlocks after reaching 110 Top MPH in Time Trial.
  const GARAGE_UNLOCK_TOP_MPH = 0;

  const LS_KEYS = {
    selectedCar: 'benji_selected_car_v1',
    garageUnlocked: 'benji_garage_unlocked_v1',
    bestTopMph: 'benji_best_topmph_v1',
    unlockChampion: 'benji_unlock_champion_v1',
    unlockLegend: 'benji_unlock_legend_v1'
  };

  function getSelectedCarId() {
    const v = localStorage.getItem(LS_KEYS.selectedCar);
    return GARAGE_CARS.some(c => c.id === v) ? v : GARAGE_CARS[0].id;
  }
  function setSelectedCarId(id) {
    if (!GARAGE_CARS.some(c => c.id === id)) return;
    localStorage.setItem(LS_KEYS.selectedCar, id);
  }
  function getBestTopMph() {
    const v = Number(localStorage.getItem(LS_KEYS.bestTopMph) || '0');
    return Number.isFinite(v) ? v : 0;
  }
  function setBestTopMph(v) {
    const n = Math.max(0, Math.floor(v || 0));
    localStorage.setItem(LS_KEYS.bestTopMph, String(n));
  }
  function isGarageUnlocked() {
    if (GARAGE_UNLOCK_TOP_MPH <= 0) return true;
    const explicit = localStorage.getItem(LS_KEYS.garageUnlocked);
    if (explicit === '1') return true;
    return getBestTopMph() >= GARAGE_UNLOCK_TOP_MPH;
  }
  function markGarageUnlocked() {
    localStorage.setItem(LS_KEYS.garageUnlocked, '1');
  }


function isChampionUnlocked() {
  return localStorage.getItem(LS_KEYS.unlockChampion) === '1';
}
function unlockChampion() {
  localStorage.setItem(LS_KEYS.unlockChampion, '1');
}
function isLegendUnlocked() {
  return localStorage.getItem(LS_KEYS.unlockLegend) === '1';
}
function unlockLegend() {
  localStorage.setItem(LS_KEYS.unlockLegend, '1');
}



// --- Champion Race (new mode) ---
// Unlock: win Race to 100.

// Championship Race is a "speed duel":
// First to reach the target speed triggers the checkered finish line.
// Whoever crosses the line *qualified* wins.
const CHAMP_TARGET_MPH = 500;

// Lose after 6 mistakes (cones + edge scrapes).
const CHAMP_MAX_MISTAKES = 6;

// "Starts fast" feel:
const CHAMP_START_MPH_PLAYER = 200;
const CHAMP_START_MPH_CHAMP  = 210;

// Where the checkered finish line starts (higher = slightly longer final sprint)
const CHAMP_FINISH_START_Y = -420;

// --- Legend Race (harder tier) ---
// Unlock: beat the Champion.
const LEGEND_TARGET_MPH = 700;
const LEGEND_MAX_MISTAKES = 4;
const LEGEND_START_MPH_PLAYER = 400;
const LEGEND_START_MPH_CHAMP  = 410;

// Helper: duel modes (Champion + Legend)
function isDuelMode() { return state.mode === MODE.CHAMP || state.mode === MODE.LEGEND; }
function duelTargetMph() { return (state.mode === MODE.LEGEND) ? LEGEND_TARGET_MPH : CHAMP_TARGET_MPH; }
function duelMaxMistakes() { return (state.mode === MODE.LEGEND) ? LEGEND_MAX_MISTAKES : CHAMP_MAX_MISTAKES; }
function duelStartPlayerMph() { return (state.mode === MODE.LEGEND) ? LEGEND_START_MPH_PLAYER : CHAMP_START_MPH_PLAYER; }
function duelStartChampMph() { return (state.mode === MODE.LEGEND) ? LEGEND_START_MPH_CHAMP : CHAMP_START_MPH_CHAMP; }
function duelBoostGain() { return CHAMP_BOOST_GAIN; } // keep same for fairness at high speed
function duelMaxMphClamp() { return (state.mode === MODE.LEGEND) ? 760 : 560; }

function mistakeIconString(mistakes, maxMistakes) {
  const m = clamp(mistakes, 0, maxMistakes);
  return ('‚ùå '.repeat(m) + '‚ö†Ô∏è '.repeat(Math.max(0, maxMistakes - m))).trim();
}



// --- constants ---
  const MPH_START = 10;
  const MPH_GOAL  = 100;
  const MPH_MAX_RACE = 120;

  const MPH_BOOST_GAIN = 10;
  const CHAMP_BOOST_GAIN = 18; // champ mode boost value (higher to make 200‚Üí500 achievable)
  const MPH_CONE_LOSS  = 15;
  const MPH_EDGE_SCRAPE_LOSS = 6;

  const MPH_RIVAL_CRASH_LOSS_PLAYER = 20;
  const MPH_RIVAL_CRASH_LOSS_RIVAL  = 12;

  const MPH_DECAY_PER_SEC = 0.65;

  // spawn spacing fix (same lane)
  const SPAWN_MIN_GAP_Y = 90;

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // MPH -> scroll speed (px/sec)
  function mphToScroll(mph, mode) {
    if (mode === MODE.RACE) {
      const clamped = clamp(mph, 0, MPH_MAX_RACE);
      return 120 + clamped * 3.1;
    }
    // Time Trial: MPH can climb; scroll uses diminishing returns after 120 MPH.
    const m = Math.max(0, mph);
    const base = 120 + Math.min(m, 120) * 3.1;
    const extra = Math.max(0, m - 120);
    return base + Math.sqrt(extra) * 22;
  }

  // --- road geometry ---
  function roadRect() {
    const margin = Math.max(24, W * 0.08);
    const roadW = Math.min(W - margin * 2, H * 2.2);
    const x = (W - roadW) / 2;
    return { x, y: 0, w: roadW, h: H };
  }

  function laneCenters() {
    const r = roadRect();
    const laneW = r.w / 3;
    return [0,1,2].map(i => r.x + laneW*(i+0.5));
  }

  function nearestLane(x) {
    const centers = laneCenters();
    let bestI = 0, bestD = Infinity;
    for (let i=0;i<centers.length;i++){
      const d = Math.abs(x - centers[i]);
      if (d < bestD) { bestD = d; bestI = i; }
    }
    return bestI;
  }

  // --- state ---
  const state = {
    mode: MODE.RACE,
    running: false,
    ended: false,

    lastT: 0,
    t: 0,

    mph: MPH_START,
    topMph: MPH_START,

    bumpTimer: 0,
    shake: 0,

    // race finish
    finishActive: false,
    finishY: -9999,
    finishCrossed: false,

    // time trial
    timeLeft: 60,

    rivalCrashCD: 0,

// champion race
champQualified: false,
playerQualified: false,
finishLeader: null,   // 'player' | 'champ' | null (who triggered the finish line)
mistakes: 0,

endCine: null,        // { type:'lose'|'win', t:number }
    forceFinishLine: false,
    finishFlash: 0,
    screenFlash: 0,
    finishBeatDone: false,
  };

  const player = {
    x: W * 0.5,
    y: H * 0.72,
    w: 90,
    h: 140,
    targetX: W * 0.5,
    dragging: false,
    dragOffsetX: 0,
  };

  const rival = {
    active: true,
    lane: 2,
    x: W * 0.5,
    y: H * 0.45,
    w: 86,
    h: 132,
    mph: MPH_START,
    yOffset: -120,
  };

const champ = {
  active: false,
  lane: 1,
  laneF: 1,
  targetLane: 1,
  x: W * 0.5,
  y: H * 0.40,
  w: 86,
  h: 132,
  mph: 0,
  yOffset: -160,
  laneCD: 0,
};


  function setMph(next) {
    const val = (state.mode === MODE.RACE)
      ? clamp(next, 0, MPH_MAX_RACE)
      : Math.max(0, next);
    state.mph = val;
    state.topMph = Math.max(state.topMph, state.mph);
  }

  function setRivalMph(next) {
    rival.mph = clamp(next, 0, MPH_MAX_RACE);
  }

  function doBump() {
    state.bumpTimer = 0.28;
    state.shake = 10;
  }

  // --- stripes ---
  const stripes = [];
  function initStripes() {
    stripes.length = 0;
    for (let i = 0; i < 20; i++) {
      stripes.push({ y: (i / 20) * H, h: 30 + Math.random() * 30 });
    }
  }
  initStripes();

  // --- objects ---
  // type: 'cone' | 'boost'
  const objs = [];
  let spawnConeCD = 0;
  let spawnBoostCD = 0;

  function laneIsClear(lane, y, minGapY) {
    for (const o of objs) {
      if (o.lane !== lane) continue;
      if (Math.abs(o.y - y) < minGapY) return false;
    }
    return true;
  }

  function spawn(type) {
    const centers = laneCenters();
    const y = -90;

    for (let tries = 0; tries < 6; tries++) {
      const lane = Math.floor(Math.random() * 3);
      if (!laneIsClear(lane, y, SPAWN_MIN_GAP_Y)) continue;

      const x = centers[lane];
      if (type === 'cone') {
        objs.push({ type, x, y, r: 28, lane });
      } else {
        objs.push({ type, x, y, r: 22, lane, phase: Math.random()*Math.PI*2 });
      }
      return;
    }
    // no clear lane found -> skip spawn
  }

  // --- UI helpers ---
  function setOverlayBg(urlOrEmpty) {
    overlay.style.backgroundImage = urlOrEmpty ? `url('${urlOrEmpty}')` : '';
  }

  function showTitleScreen() {
    state.running = false;
    state.ended = false;
    engineStop();

    // Persist best Top MPH (used for optional Garage unlock)
    try {
      const prevBest = getBestTopMph();
      if (state.topMph > prevBest) setBestTopMph(state.topMph);
      if (GARAGE_UNLOCK_TOP_MPH > 0 && state.mode === MODE.TIME && state.topMph >= GARAGE_UNLOCK_TOP_MPH) {
        markGarageUnlocked();
      }
    } catch {}

    card.style.maxHeight = '85vh';
    card.style.overflowY = 'auto';
    card.innerHTML = `
      <div style="font-size:34px; font-weight:900; margin-bottom:6px;">Benji Racers</div>

      <div class="titleArt">
        <img id="titleImg" alt="Benji Racers Title" />
      </div>

      <div style="font-size:16px; opacity:0.92; line-height:1.35;">
        Drag the car. Grab <b>Turbo</b> to go faster. Cones slow you down.
      </div>

      <div class="btnRow">
  <button id="btnRace">Race</button>
  <button id="btnTime">Time Trial</button>
  ${isChampionUnlocked() ? '<button id="btnChamp">Championship Race</button>' : ''}
  ${isLegendUnlocked() ? '<button id="btnLegend">Legend Race</button>' : ''}
  <button id="btnGarage">Garage</button>
</div>

      <div style="margin-top:12px; font-size:13px; opacity:0.75;">
        Tip: On iPad, Share ‚Üí Add to Home Screen.
      </div>
    `;

    overlay.style.display = 'flex';
    if (hint) hint.style.display = 'none';

    maybeShowAudioHint();
    maybeShowAudioHint();
    maybeShowAudioHint();

    const img = document.getElementById('titleImg');
    let triedJpg = false;

    img.onerror = () => {
      if (!triedJpg) {
        triedJpg = true;
        img.src = 'title.jpg';
        setOverlayBg('title.jpg');
      } else {
        img.closest('.titleArt').style.display = 'none';
        setOverlayBg('');
      }
    };

    img.src = 'title.png';
    setOverlayBg('title.png');

    document.getElementById('btnRace').onclick = () => { sfxPlay('click'); startGame(MODE.RACE); };
    document.getElementById('btnTime').onclick = () => { sfxPlay('click'); startGame(MODE.TIME); };
    document.getElementById('btnGarage').onclick = () => { sfxPlay('click'); showGarageScreen(); };

// Wire buttons (Champion/Legend buttons only exist when unlocked)
const champBtn = document.getElementById('btnChamp');
if (champBtn) champBtn.onclick = () => { sfxPlay('click'); startGame(MODE.CHAMP); };

const legendBtn = document.getElementById('btnLegend');
if (legendBtn) legendBtn.onclick = () => { sfxPlay('click'); startGame(MODE.LEGEND); };

  }


  function showGarageScreen() {
    state.running = false;
    state.ended = false;
    engineStop();

    const unlocked = isGarageUnlocked();
    const best = getBestTopMph();

    const selected = getSelectedCarId();
    const tiles = GARAGE_CARS.map(c => {
      const isSel = c.id === selected;
      const lockOverlay = unlocked ? '' : `
        <div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
                    background: rgba(0,0,0,0.55); border-radius:16px; font-weight:900;">
          Locked
        </div>`;
      return `
        <button class="garageTile" data-car="${c.id}" ${unlocked ? '' : 'disabled'} style="
          position:relative;
          padding: 14px;
          border-radius: 18px;
          border: 1px solid rgba(255,255,255,0.16);
          background: ${isSel ? 'rgba(255,255,255,0.92)' : 'rgba(255,255,255,0.10)'};
          color: ${isSel ? '#111' : '#fff'};
          text-align: left;
          cursor: ${unlocked ? 'pointer' : 'not-allowed'};
        ">
          <div style="font-weight:900; font-size:18px; margin-bottom:8px;">${c.name}${isSel ? ' (Selected)' : ''}</div>
          <div style="width:100%; aspect-ratio: 16/10; border-radius: 14px; overflow:hidden;
                      background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.10);">
            <img src="${c.hero}" alt="${c.name}" style="width:100%; height:100%; object-fit:contain; display:block; max-height:240px;"
              onerror="this.style.display='none'; this.parentElement.style.display='none';" />
          </div>
          ${lockOverlay}
        </button>
      `;
    }).join('');

    const lockLine = unlocked ? '' : `
      <div style="margin-top:10px; font-size:14px; opacity:0.85;">
        Unlock the Garage by reaching <b>${GARAGE_UNLOCK_TOP_MPH} Top MPH</b> in Time Trial.
        Your best: <b>${Math.round(best)} MPH</b>.
      </div>`;

    card.style.maxHeight = '85vh';
    card.style.overflowY = 'auto';
    card.innerHTML = `
      <div style="font-size:34px; font-weight:900; margin-bottom:6px;">Garage</div>
      <div style="font-size:15px; opacity:0.90; line-height:1.35;">
        Pick your car.
      </div>

      <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:14px; margin-top:14px;">
        ${tiles}
      </div>

      ${lockLine}

      <div class="btnRow" style="margin-top:14px; flex-wrap:wrap;">
        <button id="btnGarageRace">Race</button>
        <button id="btnGarageTime">Time Trial</button>
        <button id="btnGarageBack">Back to Menu</button>
      </div>
    `;

    overlay.style.display = 'flex';
    if (hint) hint.style.display = 'none';

    // Tile selection
    const btns = Array.from(card.querySelectorAll('.garageTile'));
    for (const b of btns) {
      b.addEventListener('click', () => {
        if (!unlocked) return;
        const id = b.getAttribute('data-car');
        setSelectedCarId(id);
        sfxPlay('click');
        // refresh screen so "Selected" moves
        showGarageScreen();
      });
    }

    document.getElementById('btnGarageRace').onclick = () => { sfxPlay('click'); startGame(MODE.RACE); };
    document.getElementById('btnGarageTime').onclick = () => { sfxPlay('click'); startGame(MODE.TIME); };
    document.getElementById('btnGarageBack').onclick = () => { sfxPlay('click'); showTitleScreen(); };

    maybeShowAudioHint();
  }


  
  function spawnOverlayConfetti() {
    // Lightweight DOM confetti (no assets). Clears itself.
    const box = document.createElement('div');
    box.id = 'confettiBox';
    const pieces = 36;
    const glyphs = ['üéâ','‚ú®','üéä','‚≠êÔ∏è','üíõ','üíô','üíñ','üíö'];
    for (let i = 0; i < pieces; i++) {
      const s = document.createElement('div');
      s.className = 'confettiPiece';
      s.textContent = glyphs[(Math.random()*glyphs.length)|0];
      const left = Math.random()*100;
      const delay = Math.random()*0.35;
      const drift = (Math.random()*2 - 1) * 220;
      s.style.left = left + 'vw';
      s.style.animationDelay = delay + 's';
      s.style.setProperty('--x', drift + 'px');
      box.appendChild(s);
    }
    overlay.appendChild(box);
    // Remove after animation
    setTimeout(() => { try { box.remove(); } catch(e){} }, 2200);
  }

function showEndScreen(title, bodyHtml) {
    state.running = false;
    state.ended = true;
    engineStop();

    // Persist best Top MPH (used for optional Garage unlock)
    try {
      const prevBest = getBestTopMph();
      if (state.topMph > prevBest) setBestTopMph(state.topMph);
      if (GARAGE_UNLOCK_TOP_MPH > 0 && state.mode === MODE.TIME && state.topMph >= GARAGE_UNLOCK_TOP_MPH) {
        markGarageUnlocked();
      }
    } catch {}

    card.style.maxHeight = '85vh';
    card.style.overflowY = 'auto';
    card.innerHTML = `
      <div style="font-size:34px; font-weight:900; margin-bottom:6px;">${title}</div>
      <div style="font-size:16px; opacity:0.92; line-height:1.35;">
        ${bodyHtml}
        <div style="margin-top:12px;"><b>Top MPH:</b> ${Math.round(state.topMph)}</div>
      </div>
      <div class="btnRow">
        <button id="btnTry">Try Again</button>
        <button id="btnMenu">Back to Menu</button>
      </div>
    `;

    // Keep the same background image as the title screen if available
    overlay.style.display = 'flex';
    if (hint) hint.style.display = 'none';

    document.getElementById('btnTry').onclick = () => { sfxPlay('click'); startGame(state.mode); };
    document.getElementById('btnMenu').onclick = () => { sfxPlay('click'); showTitleScreen(); };
  }

  function startGame(mode) {
    state.mode = mode;
    overlay.style.display = 'none';
    setOverlayBg('');
    if (hint) hint.style.display = 'block';
    resetGame();
    state.running = true;
    engineStart();
  }

  // iOS double-tap zoom reduction (best effort)
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive: false });

  // --- reset ---
  function resetGame() {
    const r = roadRect();
    player.x = r.x + r.w * 0.5;
    player.targetX = player.x;
    player.y = H * 0.72;

    state.mph = MPH_START;
    state.topMph = MPH_START;

    state.bumpTimer = 0;
    state.shake = 0;
    state.rivalCrashCD = 0;

    state.finishActive = false;
    state.finishCrossed = false;
    state.finishY = -9999;

    state.timeLeft = 60;
    // Champion race state
    state.playerQualified = false;
    state.champQualified = false;
    state.finishLeader = null;
    state.mistakes = 0;
    state.endCine = null;
    state.forceFinishLine = false;
    state.finishFlash = 0;
    state.screenFlash = 0;
    state.finishBeatDone = false;

    champ.active = false;
    champ.lane = 1;
    champ.laneF = 1;
    champ.targetLane = 1;
    champ.mph = 0;
    champ.yOffset = -160;
    champ.laneCD = 0;

    objs.length = 0;
    initStripes();
    spawnConeCD = 0;
    spawnBoostCD = 0;

    if (state.mode === MODE.RACE) {
      rival.active = true;

      const playerLane = nearestLane(player.x);
      const adj = [playerLane - 1, playerLane + 1].filter(n => n >= 0 && n <= 2);
      rival.lane = (adj.length ? adj[Math.floor(Math.random()*adj.length)] : Math.floor(Math.random()*3));
      rival.yOffset = (Math.random() < 0.5) ? -140 : 40;

      setRivalMph(clamp(MPH_START + (Math.random()*8 - 4), 6, 18));
      updateRivalX();
      rival.y = player.y + rival.yOffset;
    } else if (state.mode === MODE.CHAMP || state.mode === MODE.LEGEND) {
      // Duel modes: Champion + Legend
      rival.active = false;

      // Start fast (mode-specific)
      setMph(duelStartPlayerMph());
      state.topMph = Math.max(state.topMph, state.mph);

      state.playerQualified = false;
      state.champQualified = false;
      state.finishLeader = null;
      state.mistakes = 0;

      champ.active = true;
      champ.lane = 1;
      champ.laneF = 1;
      champ.targetLane = 1;
      champ.mph = duelStartChampMph();
      champ.yOffset = -160;
      champ.laneCD = 0.6;

      updateChampX();
      champ.y = player.y + champ.yOffset;
    } else {
      rival.active = false;
    }
  }

  // --- input (drag) ---
  function pointerPos(e) {
    if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function onDown(e) {
    unlockAudioOnce();
    if (!state.running) return;
    const p = pointerPos(e);
    player.dragging = true;
    player.dragOffsetX = player.x - p.x;
    player.targetX = p.x + player.dragOffsetX;
    e.preventDefault?.();
  }

  function onMove(e) {
    if (!state.running || !player.dragging) return;
    const p = pointerPos(e);
    player.targetX = p.x + player.dragOffsetX;
    e.preventDefault?.();
  }

  function onUp() { player.dragging = false; }

  window.addEventListener('mousedown', onDown);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
  window.addEventListener('touchstart', onDown, { passive: false });
  window.addEventListener('touchmove', onMove, { passive: false });
  window.addEventListener('touchend', onUp, { passive: true });
  window.addEventListener('touchcancel', onUp, { passive: true });

  // --- drawing ---
  function drawRoad(r) {
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#1f5f2a';
    ctx.fillRect(0, 0, r.x, H);
    ctx.fillRect(r.x + r.w, 0, W - (r.x + r.w), H);

    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(r.x, r.y, r.w, r.h);

    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(r.x, 0); ctx.lineTo(r.x, H);
    ctx.moveTo(r.x + r.w, 0); ctx.lineTo(r.x + r.w, H);
    ctx.stroke();

    const laneW = r.w / 3;
    ctx.strokeStyle = 'rgba(255,255,255,0.33)';
    ctx.lineWidth = 5;
    ctx.setLineDash([22, 18]);
    ctx.beginPath();
    ctx.moveTo(r.x + laneW, 0); ctx.lineTo(r.x + laneW, H);
    ctx.moveTo(r.x + laneW*2, 0); ctx.lineTo(r.x + laneW*2, H);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    for (const s of stripes) {
      ctx.fillRect(r.x + r.w*0.5 - 6, s.y, 12, s.h);
    }
  }

  function drawCone(o) {
    ctx.save();
    ctx.translate(o.x, o.y);

    ctx.fillStyle = '#ff8a00';
    ctx.beginPath();
    ctx.moveTo(0, -o.r);
    ctx.lineTo(-o.r*0.85, o.r);
    ctx.lineTo(o.r*0.85, o.r);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(-o.r*0.8, o.r*0.55, o.r*1.6, o.r*0.35);

    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillRect(-o.r*0.45, 0, o.r*0.9, o.r*0.22);

    ctx.restore();
  }

  function drawBoost(o, t) {
    const pulse = 1 + 0.10*Math.sin(t*6 + o.phase);
    const s = o.r * pulse;

    ctx.save();
    ctx.translate(o.x, o.y);

    ctx.fillStyle = 'rgba(255, 212, 0, 0.18)';
    ctx.beginPath();
    ctx.arc(0, 0, s*1.25, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#ffd400';
    ctx.beginPath();
    ctx.moveTo(-s*0.15, -s*1.05);
    ctx.lineTo( s*0.25, -s*0.20);
    ctx.lineTo( s*0.00, -s*0.20);
    ctx.lineTo( s*0.35,  s*1.05);
    ctx.lineTo(-s*0.35,  s*0.10);
    ctx.lineTo(-s*0.05,  s*0.10);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.restore();
  }

  function drawFinishLine(r) {
    const y = state.finishY;
    const tile = 22;
    const cols = Math.ceil(r.w / tile);
    const rows = 2;

    ctx.save();
    ctx.translate(r.x, y);
    for (let row=0; row<rows; row++) {
      for (let col=0; col<cols; col++) {
        const isWhite = (row + col) % 2 === 0;
        ctx.fillStyle = isWhite ? 'rgba(255,255,255,0.95)' : 'rgba(0,0,0,0.95)';
        ctx.fillRect(col*tile, row*tile, tile, tile);
      }
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, cols*tile, rows*tile);
    // Flash the finish line area
    if (state.finishFlash > 0) {
      const a = Math.min(1, state.finishFlash / 0.22);
      ctx.fillStyle = `rgba(255,255,255,${0.55 * a})`;
      ctx.fillRect(0, -60, cols*tile, rows*tile + 120);
    }

    ctx.restore();
  }

  function drawSpriteCentered(img, x, y, w, h, wobble=0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(wobble);

    if (img) {
      const scale = Math.min(w / img.width, h / img.height);
      const dw = img.width * scale;
      const dh = img.height * scale;
      ctx.drawImage(img, -dw/2, -dh/2, dw, dh);
    } else {
      ctx.fillStyle = '#e33';
      ctx.fillRect(-w/2, -h/2, w, h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(-w*0.18, -h*0.35, w*0.36, h*0.2);
    }

    ctx.restore();
  }

  // IMPORTANT: update rival.x before collision checks
  function updateRivalX() {
    const centers = laneCenters();
    rival.x = centers[rival.lane] + Math.sin(state.t*1.5) * 6;
  }

  function updateChampX() {
    const centers = laneCenters();
    const i = clamp(champ.laneF, 0, 2);
    const left = Math.floor(i);
    const right = Math.min(2, left + 1);
    const frac = i - left;
    champ.x = (centers[left] * (1 - frac) + centers[right] * frac) + Math.sin(state.t*1.1) * 5;
  }


  function fmtTime(seconds) {
    const s = Math.max(0, Math.ceil(seconds));
    const m = Math.floor(s / 60);
    const r = s % 60;
    return `${m}:${String(r).padStart(2, '0')}`;
  }

  function drawHUD() {
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.font = '800 22px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(`MPH: ${Math.round(state.mph)}`, 14, 30);

    if (state.mode === MODE.RACE) {
      const barX = 14, barY = 44, barW = 220, barH = 14;
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.fillRect(barX, barY, barW, barH);

      const pct = clamp(state.mph / MPH_GOAL, 0, 1);
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.fillRect(barX, barY, barW * pct, barH);

      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barW, barH);

      ctx.font = '650 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.72)';
      ctx.fillText(`Goal: ${MPH_GOAL}`, barX + barW + 10, barY + 12);

      if (state.finishActive && !state.finishCrossed) {
        ctx.fillStyle = 'rgba(255,255,255,0.80)';
        ctx.font = '800 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText(`FINISH LINE!`, 14, 76);
      
  // Full-screen flash (finish-line beat)
  if (state.screenFlash > 0) {
    const a = Math.min(1, state.screenFlash / 0.14);
    ctx.save();
    ctx.fillStyle = `rgba(255,255,255,${0.35 * a})`;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }
}
    } else if (isDuelMode()) {
      // Championship Race: speed duel to the (hidden) target
      const barX = 14, barY = 44, barW = 280, barH = 14;
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.fillRect(barX, barY, barW, barH);

      const pPct = clamp((state.mph - CHAMP_START_MPH_PLAYER) / (CHAMP_TARGET_MPH - CHAMP_START_MPH_PLAYER), 0, 1);
      const cPct = clamp((champ.mph - CHAMP_START_MPH_PLAYER) / (CHAMP_TARGET_MPH - CHAMP_START_MPH_PLAYER), 0, 1);

      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barW, barH);

      const py = barY + barH/2;
      const px = barX + barW * pPct;
      const cx = barX + barW * cPct;

      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.beginPath(); ctx.arc(px, py, 6, 0, Math.PI*2); ctx.fill();

      ctx.fillStyle = 'rgba(255,120,120,0.92)';
      ctx.beginPath(); ctx.arc(cx, py, 6, 0, Math.PI*2); ctx.fill();

      ctx.font = '800 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      ctx.fillText('YOU', barX, barY + barH + 16);
      ctx.fillStyle = 'rgba(255,120,120,0.86)';
      ctx.fillText((state.mode === MODE.LEGEND) ? 'LEGEND' : 'CHAMP', barX + 58, barY + barH + 16);

      ctx.font = '800 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillText(mistakeIconString(state.mistakes, duelMaxMistakes()), 14, 84);

      if (state.finishActive && !state.finishCrossed) {
        ctx.fillStyle = 'rgba(255,255,255,0.80)';
        ctx.font = '900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('FINAL SPRINT!', 14, 108);
      }
    } else {
      ctx.font = '800 18px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillText(`TIME: ${fmtTime(state.timeLeft)}`, 14, 56);

      ctx.font = '650 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.72)';
      ctx.fillText(`Top: ${Math.round(state.topMph)} MPH`, 14, 76);
    }
  }

  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr) {
    const px = Math.max(rx, Math.min(cx, rx + rw));
    const py = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - px;
    const dy = cy - py;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function rectRectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }


function drawCars(wob) {
  // Rival (race mode)
  if (state.mode === MODE.RACE && rival.active) {
    drawSpriteCentered(car2OK ? car2 : null, rival.x, rival.y, rival.w, rival.h, wob * 0.35);
  }

  // Champion (champion mode) - uses the same rival sprite for now
  if (isDuelMode() && champ.active) {
    drawSpriteCentered((state.mode === MODE.LEGEND && legendCarOK) ? legendCar : (champCarOK ? champCar : null), champ.x, champ.y, champ.w, champ.h, wob * 0.20);
  }

  // Player car depends on Garage selection
  const sel = getSelectedCarId();
  const rec = carSprites[sel] || carSprites[GARAGE_CARS[0].id] || null;
  const pImg = (rec && rec.ok) ? rec.img : null;
  drawSpriteCentered(pImg, player.x, player.y, player.w, player.h, wob);
}


  // --- main loop ---
  function tick(ts) {
    requestAnimationFrame(tick);
    const t = ts / 1000;
    const dt = Math.min(0.033, state.lastT ? (t - state.lastT) : 0.016);
    state.lastT = t;
    state.t = t;

    // When menu/end is up, do NOT draw the track/HUD behind it.
    if (!state.running) {
      ctx.fillStyle = '#0b0b0b';
      ctx.fillRect(0, 0, W, H);
      return;
    }

    if (state.bumpTimer > 0) state.bumpTimer -= dt;
    if (state.shake > 0) state.shake = Math.max(0, state.shake - dt*30);
    if (state.rivalCrashCD > 0) state.rivalCrashCD = Math.max(0, state.rivalCrashCD - dt);

    // time trial countdown
    if (state.mode === MODE.TIME) {
      state.timeLeft -= dt;
      if (state.timeLeft <= 0) {
        sfxPlay('win');
        spawnOverlayConfetti();
        showEndScreen('Time!', 'Time trial complete.');
        return;
      }
    }

    // mph decay
    if (MPH_DECAY_PER_SEC > 0) setMph(state.mph - MPH_DECAY_PER_SEC * dt);

    // lose if mph hits 0
    if (state.mph <= 0.001) {
      sfxPlay('lose');
      showEndScreen('Oh no!', 'Your speed hit <b>0 MPH</b>.');
      return;
    }

    // rival (race mode only)
    if (state.mode === MODE.RACE && rival.active) {
      const chase = (state.mph - rival.mph) * 0.18;
      const wobble = (Math.sin(t*0.7) * 0.8) + (Math.random()-0.5)*0.35;
      setRivalMph(rival.mph + chase*dt + wobble*dt);

      const rel = rival.mph - state.mph;
      rival.yOffset += (-rel * 0.55) * dt;
      rival.yOffset = clamp(rival.yOffset, -220, 160);
      rival.y = player.y + rival.yOffset;

      updateRivalX(); // keep x current BEFORE object collisions
    }


// champion (duel modes: Champion + Legend)
if (isDuelMode() && champ.active) {
  // End cinematic disables normal interaction
  if (state.endCine) {
    state.endCine.t += dt;

    if (state.endCine.type === 'lose') {
      // player slows, champ surges and passes
      setMph(state.mph + (120 - state.mph) * (dt * 2.4));
      champ.mph += (520 - champ.mph) * (dt * 2.0);
      champ.yOffset += (-340 - champ.yOffset) * (dt * 2.2); // champ shoots ahead
    } else {
      // win: player keeps momentum, champ falls back
      setMph(state.mph + (240 - state.mph) * (dt * 1.8));
      champ.mph += (180 - champ.mph) * (dt * 1.8);
      champ.yOffset += (140 - champ.yOffset) * (dt * 2.0); // champ drops behind
    }

    champ.y = player.y + champ.yOffset;
    updateChampX();

    // Finish-line beat (flash + whoosh) once per cinematic
    if (!state.finishBeatDone && state.endCine.t > 0.42) {
      state.finishBeatDone = true;
      state.finishFlash = 0.22;
      state.screenFlash = 0.14;
      state.shake = Math.max(state.shake, 9);
      sfxPlay('boost'); // reused as whoosh
    }

    if (state.endCine.t > 1.15) {
      if (state.endCine.type === 'lose') {
        sfxPlay('lose');
        showEndScreen('Oh no!', (state.mode === MODE.LEGEND)
          ? `The Legend beat you.<br><b>Crashes:</b> ${state.mistakes}/${duelMaxMistakes()}`
          : `The Champion beat you.<br><b>Crashes:</b> ${state.mistakes}/${duelMaxMistakes()}`);
      } else {
        sfxPlay('win');
        spawnOverlayConfetti();
        try { if (state.mode === MODE.CHAMP) unlockLegend(); } catch {}
        showEndScreen('You Win!', (state.mode === MODE.LEGEND) ? `You beat the Legend!` : `You beat the Champion!`);
      }
      return;
    }
  } else {
    // Normal champ race updates

    // Qualification (reaching target speed) triggers the finish line.
    if (!state.playerQualified && state.mph >= duelTargetMph()) state.playerQualified = true;
    if (!state.champQualified && champ.mph >= duelTargetMph()) state.champQualified = true;

    if (!state.finishActive && (state.playerQualified || state.champQualified)) {
      state.finishActive = true;
      state.finishCrossed = false;
      state.finishY = CHAMP_FINISH_START_Y;

      // Who triggered the finish first (for tie-breaking flavor if needed)
      if (!state.finishLeader) {
        if (state.playerQualified && !state.champQualified) state.finishLeader = 'player';
        else if (state.champQualified && !state.playerQualified) state.finishLeader = 'champ';
        else state.finishLeader = (state.mph >= champ.mph) ? 'player' : 'champ';
      }

      // Cut the champ's speed slightly so the final sprint feels dramatic
      champ.mph = Math.min(champ.mph, Math.max(220, state.mph + 18));
      champ.yOffset = -140;
    }

    // Light rubber-banding on *speed* (not hidden distance)
    const speedGap = champ.mph - state.mph; // + means champ faster
    let target = state.mph + 10; // champ baseline advantage

    if (speedGap > 40) target -= 10;   // champ too far ahead -> ease
    if (speedGap < -25) target += 16;  // champ behind -> surge a bit

    // Don't let AI "teleport" to 500; boosts do the big jumps.
    target = clamp(target, 190, 280);

    champ.mph += (target - champ.mph) * (dt * 2.6);
    champ.mph = Math.max(0, champ.mph);

    // Occasional lane changes (more frequent before finish)
    const cdBase = state.finishActive ? 0.45 : 0.70;
    champ.laneCD -= dt;
    if (champ.laneCD <= 0) {
      champ.laneCD = cdBase + Math.random() * 0.55;
      champ.targetLane = Math.floor(Math.random() * 3);
    }
    champ.laneF += (champ.targetLane - champ.laneF) * (dt * 4.0);
    champ.laneF = clamp(champ.laneF, 0, 2);
    updateChampX();

    // Place champ vertically relative to speed gap (feel like a race)
    const pxPerMph = state.finishActive ? 3.8 : 2.6;
    champ.yOffset = clamp(-160 - speedGap * pxPerMph, -280, 160);
    champ.y = player.y + champ.yOffset;
  }
}


    // finish trigger (race mode only)
    if (state.mode === MODE.RACE && !state.finishActive && state.mph >= MPH_GOAL) {
      state.finishActive = true;
      state.finishCrossed = false;
      state.finishY = -80;

      setRivalMph(Math.min(rival.mph, clamp(state.mph - (6 + Math.random()*10), 0, MPH_MAX_RACE)));
      rival.yOffset = 70 + Math.random()*60;
      rival.y = player.y + rival.yOffset;
      updateRivalX();
    }

    const scroll = mphToScroll(state.mph, state.mode) * dt;

    // move stripes
    for (const s of stripes) {
      s.y += scroll;
      if (s.y > H + 80) {
        s.y = -80;
        s.h = 30 + Math.random() * 30;
      }
    }

    // spawning
    spawnConeCD -= dt;
    spawnBoostCD -= dt;

    const spdFactor = clamp(state.mph / 60, 0.3, 1.45);
    const boostBias = (state.mode === MODE.TIME) ? 1.25 : (isDuelMode() ? 1.15 : 1.0);

    const allowSpawns = (state.mode === MODE.TIME) || (!state.finishActive);
    if (allowSpawns) {
      if (spawnConeCD <= 0) {
        spawn('cone');
        spawnConeCD = (1.15 / spdFactor) + Math.random() * 0.45;
      }
      if (spawnBoostCD <= 0) {
        spawn('boost');
        spawnBoostCD = ((0.90 / spdFactor) + Math.random() * 0.55) / boostBias;
      }
    }

    // update player position + clamp
    const r = roadRect();
    const minX = r.x + player.w * 0.42;
    const maxX = r.x + r.w - player.w * 0.42;
    player.targetX = clamp(player.targetX, minX, maxX);
    player.x += (player.targetX - player.x) * 0.22;

    // edge scrape penalty
    const edgePad = 8;
    const tooLeft = (player.x - player.w*0.5 < r.x + edgePad);
    const tooRight = (player.x + player.w*0.5 > r.x + r.w - edgePad);
    if ((tooLeft || tooRight) && state.bumpTimer <= 0) {
      doBump();
      sfxPlay('bump');
      setMph(state.mph - MPH_EDGE_SCRAPE_LOSS);

      if (isDuelMode() && !state.endCine) {
        state.mistakes++;
        if (state.mistakes >= duelMaxMistakes()) state.endCine = { type: 'lose', t: 0 };
          state.forceFinishLine = true;
          state.finishBeatDone = false;
      }
    }

    // update objects + collisions for both cars
    for (let i = objs.length - 1; i >= 0; i--) {
      const o = objs[i];
      o.y += scroll;

      // player hitbox
      const prx = player.x - player.w*0.34;
      const pry = player.y - player.h*0.40;
      const prw = player.w*0.68;
      const prh = player.h*0.80;

      if (rectCircleCollide(prx, pry, prw, prh, o.x, o.y, o.r)) {
        if (o.type === 'boost') {
          setMph(state.mph + (isDuelMode() ? duelBoostGain() : MPH_BOOST_GAIN));
          sfxPlay('boost');
        } else {
          doBump();
          sfxPlay('cone');
          setMph(state.mph - MPH_CONE_LOSS);

          if (isDuelMode() && !state.endCine) {
            state.mistakes++;
            if (state.mistakes >= duelMaxMistakes()) state.endCine = { type: 'lose', t: 0 };
          state.forceFinishLine = true;
          state.finishBeatDone = false;
          }
        }
        objs.splice(i, 1);
        continue;
      }

      // rival clears objects too (race mode only)
      if (state.mode === MODE.RACE && rival.active) {
        const rrx = rival.x - rival.w*0.34;
        const rry = rival.y - rival.h*0.40;
        const rrw = rival.w*0.68;
        const rrh = rival.h*0.80;

        if (rectCircleCollide(rrx, rry, rrw, rrh, o.x, o.y, o.r)) {
          if (o.type === 'boost') setRivalMph(rival.mph + MPH_BOOST_GAIN);
          else setRivalMph(rival.mph - MPH_CONE_LOSS);
          objs.splice(i, 1);
          continue;
        }
      }

      // champion collects boosts too (champion mode only)
      if (isDuelMode() && champ.active && o.type === 'boost' && !state.endCine) {
        const crx = champ.x - champ.w*0.34;
        const cry = champ.y - champ.h*0.40;
        const crw = champ.w*0.68;
        const crh = champ.h*0.80;
        if (rectCircleCollide(crx, cry, crw, crh, o.x, o.y, o.r)) {
          champ.mph = clamp(champ.mph + duelBoostGain(), 0, duelMaxMphClamp());
          objs.splice(i, 1);
          continue;
        }
      }

      if (o.y > H + 120) objs.splice(i, 1);
    }

    // crash into rival consequence (race mode only)
    if (state.mode === MODE.RACE && rival.active && state.rivalCrashCD <= 0) {
      const pax = player.x - player.w*0.34;
      const pay = player.y - player.h*0.40;
      const paw = player.w*0.68;
      const pah = player.h*0.80;

      const rax = rival.x - rival.w*0.34;
      const ray = rival.y - rival.h*0.40;
      const raw = rival.w*0.68;
      const rah = rival.h*0.80;

      if (rectRectCollide(pax, pay, paw, pah, rax, ray, raw, rah)) {
        doBump();
        sfxPlay('bump');
        setMph(state.mph - MPH_RIVAL_CRASH_LOSS_PLAYER);
        setRivalMph(rival.mph - MPH_RIVAL_CRASH_LOSS_RIVAL);

        // separate them to avoid sticking
        if (rival.y <= player.y) rival.yOffset -= 40;
        else rival.yOffset += 40;
        rival.yOffset = clamp(rival.yOffset, -220, 160);
        rival.y = player.y + rival.yOffset;
        updateRivalX();

        state.rivalCrashCD = 0.45;
      }
    }

    // finish line progression + win
    if ((state.mode === MODE.RACE || isDuelMode()) && state.finishActive && !state.finishCrossed) {
      state.finishY += scroll;
      if (state.finishY >= player.y - 20) {
        state.finishCrossed = true;

        if (state.mode === MODE.RACE) {
          sfxPlay('win');
        spawnOverlayConfetti();
          // Progression: winning Race unlocks Championship
          try { unlockChampion(); } catch {}
          showEndScreen('You Win!', `You reached <b>${MPH_GOAL} MPH</b> and crossed the finish line first.`);
          return;
        } else {
          // Championship Race: whoever qualified (hit the target speed) wins.
          // If both qualified, whoever is faster at the line wins.
          let winner = null; // 'player' | 'champ'
          if (state.playerQualified && !state.champQualified) winner = 'player';
          else if (state.champQualified && !state.playerQualified) winner = 'champ';
          else if (state.playerQualified && state.champQualified) winner = (state.mph >= champ.mph) ? 'player' : 'champ';
          else winner = (state.finishLeader === 'player') ? 'player' : 'champ'; // should be rare

          state.endCine = { type: (winner === 'player') ? 'win' : 'lose', t: 0 };
        }
      }
    }

    // render with shake
    ctx.save();
    if (state.shake > 0) {
      const sx = (Math.random() - 0.5) * state.shake;
      const sy = (Math.random() - 0.5) * state.shake;
      ctx.translate(sx, sy);
    }

    drawRoad(r);

    if ((state.mode === MODE.RACE || isDuelMode()) && state.finishActive && !state.finishCrossed) {
      drawFinishLine(r);
    }

    for (const o of objs) {
      if (o.type === 'cone') drawCone(o);
      else drawBoost(o, t);
    }

    const wob = (state.bumpTimer > 0) ? Math.sin(state.t*40) * 0.08 : 0;
    drawCars(wob);
    drawHUD();

    ctx.restore();
  }

  // --- boot ---
  (async () => {
    initAudio();
    maybeShowAudioHint();
    // Load all selectable player cars
    for (const c of GARAGE_CARS) {
      const r = await loadImg(c.sprite);
      carSprites[c.id] = { ok: r.ok, img: r.img };
    }

    // Rival car sprite (unchanged)
    const b = await loadImg('assets/car2.png');
    car2OK = b.ok; car2 = b.img;


    
    // Champion car sprite
    const c = await loadImg('assets/car_champion.png');
    champCarOK = c.ok; champCar = c.img;

    // Legend car sprite
    const d = await loadImg('assets/car_legend.png');
    legendCarOK = d.ok; legendCar = d.img;
showTitleScreen();
    requestAnimationFrame(tick);
  })();

})();
</script>
</body>
</html>
