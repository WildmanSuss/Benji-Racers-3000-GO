<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Benji Racers</title>
  <!-- SIMPLE BASELINE vA: forked stable build -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0b0b0b;
      height: 100%;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }

    /* Overlay takes full screen and becomes the "scene" for menu/end */
    #overlay {
      position: fixed;
      inset: 0;
      display: none; /* shown by JS when needed */
      align-items: center;
      justify-content: center;
      pointer-events: none;
      padding: 18px;

      /* background art set dynamically in JS */
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    /* Dark scrim + subtle blur feel */
    #overlay::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 50% 35%, rgba(0,0,0,0.40), rgba(0,0,0,0.82));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #overlay .card {
      position: relative;          /* above scrim */
      pointer-events: auto;
      background: rgba(15,15,15,0.72);
      color: #fff;
      padding: 18px 18px 16px;
      border-radius: 18px;
      text-align: center;
      width: min(720px, 94vw);
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.10);
    }

    /* Landscape title hero image inside the card */
    .titleArt {
      width: min(620px, 92vw);
      aspect-ratio: 16 / 9;
      margin: 10px auto 12px;
      border-radius: 16px;
      overflow: hidden;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .titleArt img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .btnRow {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 14px;
    }

    /* Sleek app buttons */
    #overlay button {
      font-size: 20px;
      font-weight: 800;
      letter-spacing: 0.2px;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      cursor: pointer;
      width: 100%;
      background: rgba(255,255,255,0.92);
      color: #111;
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      transform: translateY(0);
      transition: transform 120ms ease, filter 120ms ease;
    }
    #overlay button:active {
      transform: translateY(2px);
      filter: brightness(0.95);
    }

    #hint {
      position: fixed;
      left: 12px;
      bottom: 10px;
      color: rgba(255,255,255,0.85);
      font-size: 14px;
      background: rgba(0,0,0,0.35);
      padding: 6px 10px;
      border-radius: 10px;
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
    }

    #audioHint{
      position:fixed; right:12px; bottom:10px;
      color: rgba(255,255,255,0.70);
      font-size:12px;
      background: rgba(0,0,0,0.28);
      padding:6px 10px;
      border-radius:10px;
      user-select:none;
      -webkit-user-select:none;
      pointer-events:none;
      display:none;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="overlay">
    <div class="card" id="card"></div>
  </div>

  <div id="hint">Drag the car • Landscape works best • Add to Home Screen on iPad</div>
  <div id="audioHint">Tap once to enable sound</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const overlay = document.getElementById('overlay');
  const card = document.getElementById('card');
  const hint = document.getElementById('hint');
  const audioHint = document.getElementById('audioHint');

  // --- sizing ---
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  let W = 0, H = 0;

  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // --- load images ---
  function loadImg(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ img, ok: true });
      img.onerror = () => resolve({ img: null, ok: false });
      img.src = src;
    });
  }

  
  // ---- Audio (minimal, safe) ----
  const AUDIO_PATH = {
    engine: 'audio/engine_loop.mp3',
    boost:  'audio/boost.mp3',
    cone:   'audio/cone_hit.mp3',
    bump:   'audio/bump.mp3',
    win:    'audio/win.mp3',
    lose:   'audio/lose.mp3',
    click:  'audio/click.mp3'
  };

  const audio = {
    unlocked:false,
    engineEl:null,
    sfx:{},
    engineRate:1.0
  };

  function makeAudio(src, loop=false){
    const el = new Audio();
    el.src = src;
    el.loop = loop;
    el.preload = 'auto';
    el.playsInline = true;
    return el;
  }

  function initAudio(){
    audio.engineEl = makeAudio(AUDIO_PATH.engine, true);
    audio.engineEl.volume = 0.25;

    audio.sfx.boost = makeAudio(AUDIO_PATH.boost);
    audio.sfx.cone  = makeAudio(AUDIO_PATH.cone);
    audio.sfx.bump  = makeAudio(AUDIO_PATH.bump);
    audio.sfx.win   = makeAudio(AUDIO_PATH.win);
    audio.sfx.lose  = makeAudio(AUDIO_PATH.lose);
    audio.sfx.click = makeAudio(AUDIO_PATH.click);

    audio.sfx.boost.volume = 0.55;
    audio.sfx.cone.volume  = 0.60;
    audio.sfx.bump.volume  = 0.60;
    audio.sfx.win.volume   = 0.70;
    audio.sfx.lose.volume  = 0.65;
    audio.sfx.click.volume = 0.55;
  }

  function maybeShowAudioHint(){
    if (!audio.unlocked && audioHint) audioHint.style.display = 'block';
  }

  function unlockAudioOnce(){
    if (audio.unlocked) return;
    audio.unlocked = true;
    if (audioHint) audioHint.style.display = 'none';

    // Prime elements (iOS/Safari)
    const els = [audio.engineEl, ...Object.values(audio.sfx)];
    for (const el of els){
      if (!el) continue;
      try{
        el.muted = true;
        const p = el.play();
        if (p && p.then){
          p.then(()=>{ el.pause(); el.currentTime=0; el.muted=false; })
           .catch(()=>{ el.muted=false; });
        } else {
          el.pause(); el.currentTime=0; el.muted=false;
        }
      } catch {}
    }
  }

  function sfxPlay(name){
    if (!audio.unlocked) return;
    const el = audio.sfx[name];
    if (!el) return;
    try{
      el.pause(); el.currentTime = 0;
      el.play().catch(()=>{});
    } catch {}
  }

  function engineStart(){
    if (!audio.unlocked || !audio.engineEl) return;
    try{
      audio.engineEl.volume = 0.25;
      audio.engineEl.playbackRate = 1.0;
      audio.engineEl.play().catch(()=>{});
    } catch {}
  }
  function engineStop(){
    if (!audio.engineEl) return;
    try{ audio.engineEl.pause(); } catch {}
  }
  function engineUpdate(mph){
    if (!audio.unlocked || !audio.engineEl) return;
    const base = 0.80;
    const maxR = 1.35;
    const normalized = clamp(mph / 120, 0, 1.2);
    let target = base + normalized * 0.45;
    target = clamp(target, base, maxR);

    audio.engineRate += (target - audio.engineRate) * 0.12;
    try{ audio.engineEl.playbackRate = audio.engineRate; } catch {}

    const v = 0.18 + clamp(mph/180, 0, 1) * 0.16;
    audio.engineEl.volume = clamp(v, 0.15, 0.33);
  }

  // Unlock audio on any user gesture
  function anyGestureUnlock(){ unlockAudioOnce(); }
  window.addEventListener('mousedown', anyGestureUnlock, { passive:true });
  window.addEventListener('touchstart', anyGestureUnlock, { passive:true });

let car1 = null, car2 = null;
  let car1OK = false, car2OK = false;
  // Player selectable car sprites (loaded dynamically from GARAGE_CARS)
  const carSprites = Object.create(null); // id -> { img, ok }


  // --- modes ---
  const MODE = { RACE: 'race', TIME: 'time', GARAGE: 'garage' };

  // --- garage / car selection ---
  // Update these filenames to match your assets.
  // Sprites: used in-game for the player car.
  // Heroes: used in the Garage screen as a big display image.
  const GARAGE_CARS = [
    { id: 'red',     name: 'The Red Car',     sprite: 'assets/car_red.png',     hero: 'assets/garage_red.png' },
    { id: 'blue',    name: 'Blue Mama',    sprite: 'assets/car_blue.png',    hero: 'assets/garage_blue.png' },
    { id: 'pink',    name: 'Pink Hannah',    sprite: 'assets/car_pink.png',    hero: 'assets/garage_pink.png' },
    { id: 'green',   name: 'Benji Monster',   sprite: 'assets/car_green.png',   hero: 'assets/garage_green.png' },
    { id: 'mystery', name: 'Mystery Racer', sprite: 'assets/car_mystery.png', hero: 'assets/garage_mystery.png' },
  ];

  // Optional unlock gate (set to 0 to always unlock):
  // Example: 110 means Garage unlocks after reaching 110 Top MPH in Time Trial.
  const GARAGE_UNLOCK_TOP_MPH = 0;

  const LS_KEYS = {
    selectedCar: 'benji_selected_car_v1',
    garageUnlocked: 'benji_garage_unlocked_v1',
    bestTopMph: 'benji_best_topmph_v1'
  };

  function getSelectedCarId() {
    const v = localStorage.getItem(LS_KEYS.selectedCar);
    return GARAGE_CARS.some(c => c.id === v) ? v : GARAGE_CARS[0].id;
  }
  function setSelectedCarId(id) {
    if (!GARAGE_CARS.some(c => c.id === id)) return;
    localStorage.setItem(LS_KEYS.selectedCar, id);
  }
  function getBestTopMph() {
    const v = Number(localStorage.getItem(LS_KEYS.bestTopMph) || '0');
    return Number.isFinite(v) ? v : 0;
  }
  function setBestTopMph(v) {
    const n = Math.max(0, Math.floor(v || 0));
    localStorage.setItem(LS_KEYS.bestTopMph, String(n));
  }
  function isGarageUnlocked() {
    if (GARAGE_UNLOCK_TOP_MPH <= 0) return true;
    const explicit = localStorage.getItem(LS_KEYS.garageUnlocked);
    if (explicit === '1') return true;
    return getBestTopMph() >= GARAGE_UNLOCK_TOP_MPH;
  }
  function markGarageUnlocked() {
    localStorage.setItem(LS_KEYS.garageUnlocked, '1');
  }

  // --- constants ---
  const MPH_START = 10;
  const MPH_GOAL  = 100;
  const MPH_MAX_RACE = 120;

  const MPH_BOOST_GAIN = 10;
  const MPH_CONE_LOSS  = 15;
  const MPH_EDGE_SCRAPE_LOSS = 6;

  const MPH_RIVAL_CRASH_LOSS_PLAYER = 20;
  const MPH_RIVAL_CRASH_LOSS_RIVAL  = 12;

  const MPH_DECAY_PER_SEC = 0.65;

  // spawn spacing fix (same lane)
  const SPAWN_MIN_GAP_Y = 90;

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // MPH -> scroll speed (px/sec)
  function mphToScroll(mph, mode) {
    if (mode === MODE.RACE) {
      const clamped = clamp(mph, 0, MPH_MAX_RACE);
      return 120 + clamped * 3.1;
    }
    // Time Trial: MPH can climb; scroll uses diminishing returns after 120 MPH.
    const m = Math.max(0, mph);
    const base = 120 + Math.min(m, 120) * 3.1;
    const extra = Math.max(0, m - 120);
    return base + Math.sqrt(extra) * 22;
  }

  // --- road geometry ---
  function roadRect() {
    const margin = Math.max(24, W * 0.08);
    const roadW = Math.min(W - margin * 2, H * 2.2);
    const x = (W - roadW) / 2;
    return { x, y: 0, w: roadW, h: H };
  }

  function laneCenters() {
    const r = roadRect();
    const laneW = r.w / 3;
    return [0,1,2].map(i => r.x + laneW*(i+0.5));
  }

  function nearestLane(x) {
    const centers = laneCenters();
    let bestI = 0, bestD = Infinity;
    for (let i=0;i<centers.length;i++){
      const d = Math.abs(x - centers[i]);
      if (d < bestD) { bestD = d; bestI = i; }
    }
    return bestI;
  }

  // --- state ---
  const state = {
    mode: MODE.RACE,
    running: false,
    ended: false,

    lastT: 0,
    t: 0,

    mph: MPH_START,
    topMph: MPH_START,

    bumpTimer: 0,
    shake: 0,

    // race finish
    finishActive: false,
    finishY: -9999,
    finishCrossed: false,

    // time trial
    timeLeft: 60,

    rivalCrashCD: 0,
  };

  const player = {
    x: W * 0.5,
    y: H * 0.72,
    w: 90,
    h: 140,
    targetX: W * 0.5,
    dragging: false,
    dragOffsetX: 0,
  };

  const rival = {
    active: true,
    lane: 2,
    x: W * 0.5,
    y: H * 0.45,
    w: 86,
    h: 132,
    mph: MPH_START,
    yOffset: -120,
  };

  function setMph(next) {
    const val = (state.mode === MODE.RACE)
      ? clamp(next, 0, MPH_MAX_RACE)
      : Math.max(0, next);
    state.mph = val;
    state.topMph = Math.max(state.topMph, state.mph);
  }

  function setRivalMph(next) {
    rival.mph = clamp(next, 0, MPH_MAX_RACE);
  }

  function doBump() {
    state.bumpTimer = 0.28;
    state.shake = 10;
  }

  // --- stripes ---
  const stripes = [];
  function initStripes() {
    stripes.length = 0;
    for (let i = 0; i < 20; i++) {
      stripes.push({ y: (i / 20) * H, h: 30 + Math.random() * 30 });
    }
  }
  initStripes();

  // --- objects ---
  // type: 'cone' | 'boost'
  const objs = [];
  let spawnConeCD = 0;
  let spawnBoostCD = 0;

  function laneIsClear(lane, y, minGapY) {
    for (const o of objs) {
      if (o.lane !== lane) continue;
      if (Math.abs(o.y - y) < minGapY) return false;
    }
    return true;
  }

  function spawn(type) {
    const centers = laneCenters();
    const y = -90;

    for (let tries = 0; tries < 6; tries++) {
      const lane = Math.floor(Math.random() * 3);
      if (!laneIsClear(lane, y, SPAWN_MIN_GAP_Y)) continue;

      const x = centers[lane];
      if (type === 'cone') {
        objs.push({ type, x, y, r: 28, lane });
      } else {
        objs.push({ type, x, y, r: 22, lane, phase: Math.random()*Math.PI*2 });
      }
      return;
    }
    // no clear lane found -> skip spawn
  }

  // --- UI helpers ---
  function setOverlayBg(urlOrEmpty) {
    overlay.style.backgroundImage = urlOrEmpty ? `url('${urlOrEmpty}')` : '';
  }

  function showTitleScreen() {
    state.running = false;
    state.ended = false;
    engineStop();

    // Persist best Top MPH (used for optional Garage unlock)
    try {
      const prevBest = getBestTopMph();
      if (state.topMph > prevBest) setBestTopMph(state.topMph);
      if (GARAGE_UNLOCK_TOP_MPH > 0 && state.mode === MODE.TIME && state.topMph >= GARAGE_UNLOCK_TOP_MPH) {
        markGarageUnlocked();
      }
    } catch {}

    card.style.maxHeight = '85vh';
    card.style.overflowY = 'auto';
    card.innerHTML = `
      <div style="font-size:34px; font-weight:900; margin-bottom:6px;">Benji Racers</div>

      <div class="titleArt">
        <img id="titleImg" alt="Benji Racers Title" />
      </div>

      <div style="font-size:16px; opacity:0.92; line-height:1.35;">
        Drag the car. Grab <b>Turbo</b> to go faster. Cones slow you down.
      </div>

      <div class="btnRow">
        <button id="btnRace">Race</button>
        <button id="btnTime">Time Trial</button>
        <button id="btnGarage">Garage</button>
      </div>

      <div style="margin-top:12px; font-size:13px; opacity:0.75;">
        Tip: On iPad, Share → Add to Home Screen.
      </div>
    `;

    overlay.style.display = 'flex';
    if (hint) hint.style.display = 'none';

    maybeShowAudioHint();
    maybeShowAudioHint();
    maybeShowAudioHint();

    const img = document.getElementById('titleImg');
    let triedJpg = false;

    img.onerror = () => {
      if (!triedJpg) {
        triedJpg = true;
        img.src = 'title.jpg';
        setOverlayBg('title.jpg');
      } else {
        img.closest('.titleArt').style.display = 'none';
        setOverlayBg('');
      }
    };

    img.src = 'title.png';
    setOverlayBg('title.png');

    document.getElementById('btnRace').onclick = () => { sfxPlay('click'); startGame(MODE.RACE); };
    document.getElementById('btnTime').onclick = () => { sfxPlay('click'); startGame(MODE.TIME); };
    document.getElementById('btnGarage').onclick = () => { sfxPlay('click'); showGarageScreen(); };
  }


  function showGarageScreen() {
    state.running = false;
    state.ended = false;
    engineStop();

    const unlocked = isGarageUnlocked();
    const best = getBestTopMph();

    const selected = getSelectedCarId();
    const tiles = GARAGE_CARS.map(c => {
      const isSel = c.id === selected;
      const lockOverlay = unlocked ? '' : `
        <div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
                    background: rgba(0,0,0,0.55); border-radius:16px; font-weight:900;">
          Locked
        </div>`;
      return `
        <button class="garageTile" data-car="${c.id}" ${unlocked ? '' : 'disabled'} style="
          position:relative;
          padding: 14px;
          border-radius: 18px;
          border: 1px solid rgba(255,255,255,0.16);
          background: ${isSel ? 'rgba(255,255,255,0.92)' : 'rgba(255,255,255,0.10)'};
          color: ${isSel ? '#111' : '#fff'};
          text-align: left;
          cursor: ${unlocked ? 'pointer' : 'not-allowed'};
        ">
          <div style="font-weight:900; font-size:18px; margin-bottom:8px;">${c.name}${isSel ? ' (Selected)' : ''}</div>
          <div style="width:100%; aspect-ratio: 16/10; border-radius: 14px; overflow:hidden;
                      background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.10);">
            <img src="${c.hero}" alt="${c.name}" style="width:100%; height:100%; object-fit:contain; display:block; max-height:240px;"
              onerror="this.style.display='none'; this.parentElement.style.display='none';" />
          </div>
          ${lockOverlay}
        </button>
      `;
    }).join('');

    const lockLine = unlocked ? '' : `
      <div style="margin-top:10px; font-size:14px; opacity:0.85;">
        Unlock the Garage by reaching <b>${GARAGE_UNLOCK_TOP_MPH} Top MPH</b> in Time Trial.
        Your best: <b>${Math.round(best)} MPH</b>.
      </div>`;

    card.style.maxHeight = '85vh';
    card.style.overflowY = 'auto';
    card.innerHTML = `
      <div style="font-size:34px; font-weight:900; margin-bottom:6px;">Garage</div>
      <div style="font-size:15px; opacity:0.90; line-height:1.35;">
        Pick your car.
      </div>

      <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:14px; margin-top:14px;">
        ${tiles}
      </div>

      ${lockLine}

      <div class="btnRow" style="margin-top:14px; flex-wrap:wrap;">
        <button id="btnGarageRace">Race to 100</button>
        <button id="btnGarageTime">Time Trial</button>
        <button id="btnGarageBack">Back to Menu</button>
      </div>
    `;

    overlay.style.display = 'flex';
    if (hint) hint.style.display = 'none';

    // Tile selection
    const btns = Array.from(card.querySelectorAll('.garageTile'));
    for (const b of btns) {
      b.addEventListener('click', () => {
        if (!unlocked) return;
        const id = b.getAttribute('data-car');
        setSelectedCarId(id);
        sfxPlay('click');
        // refresh screen so "Selected" moves
        showGarageScreen();
      });
    }

    document.getElementById('btnGarageRace').onclick = () => { sfxPlay('click'); startGame(MODE.RACE); };
    document.getElementById('btnGarageTime').onclick = () => { sfxPlay('click'); startGame(MODE.TIME); };
    document.getElementById('btnGarageBack').onclick = () => { sfxPlay('click'); showTitleScreen(); };

    maybeShowAudioHint();
  }


  function showEndScreen(title, bodyHtml) {
    state.running = false;
    state.ended = true;
    engineStop();

    // Persist best Top MPH (used for optional Garage unlock)
    try {
      const prevBest = getBestTopMph();
      if (state.topMph > prevBest) setBestTopMph(state.topMph);
      if (GARAGE_UNLOCK_TOP_MPH > 0 && state.mode === MODE.TIME && state.topMph >= GARAGE_UNLOCK_TOP_MPH) {
        markGarageUnlocked();
      }
    } catch {}

    card.style.maxHeight = '85vh';
    card.style.overflowY = 'auto';
    card.innerHTML = `
      <div style="font-size:34px; font-weight:900; margin-bottom:6px;">${title}</div>
      <div style="font-size:16px; opacity:0.92; line-height:1.35;">
        ${bodyHtml}
        <div style="margin-top:12px;"><b>Top MPH:</b> ${Math.round(state.topMph)}</div>
      </div>
      <div class="btnRow">
        <button id="btnTry">Try Again</button>
        <button id="btnMenu">Back to Menu</button>
      </div>
    `;

    // Keep the same background image as the title screen if available
    overlay.style.display = 'flex';
    if (hint) hint.style.display = 'none';

    document.getElementById('btnTry').onclick = () => { sfxPlay('click'); startGame(state.mode); };
    document.getElementById('btnMenu').onclick = () => { sfxPlay('click'); showTitleScreen(); };
  }

  function startGame(mode) {
    state.mode = mode;
    overlay.style.display = 'none';
    setOverlayBg('');
    if (hint) hint.style.display = 'block';
    resetGame();
    state.running = true;
    engineStart();
  }

  // iOS double-tap zoom reduction (best effort)
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive: false });

  // --- reset ---
  function resetGame() {
    const r = roadRect();
    player.x = r.x + r.w * 0.5;
    player.targetX = player.x;
    player.y = H * 0.72;

    state.mph = MPH_START;
    state.topMph = MPH_START;

    state.bumpTimer = 0;
    state.shake = 0;
    state.rivalCrashCD = 0;

    state.finishActive = false;
    state.finishCrossed = false;
    state.finishY = -9999;

    state.timeLeft = 60;

    objs.length = 0;
    initStripes();
    spawnConeCD = 0;
    spawnBoostCD = 0;

    if (state.mode === MODE.RACE) {
      rival.active = true;

      const playerLane = nearestLane(player.x);
      const adj = [playerLane - 1, playerLane + 1].filter(n => n >= 0 && n <= 2);
      rival.lane = (adj.length ? adj[Math.floor(Math.random()*adj.length)] : Math.floor(Math.random()*3));
      rival.yOffset = (Math.random() < 0.5) ? -140 : 40;

      setRivalMph(clamp(MPH_START + (Math.random()*8 - 4), 6, 18));
      updateRivalX();
      rival.y = player.y + rival.yOffset;
    } else {
      rival.active = false;
    }
  }

  // --- input (drag) ---
  function pointerPos(e) {
    if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function onDown(e) {
    unlockAudioOnce();
    if (!state.running) return;
    const p = pointerPos(e);
    player.dragging = true;
    player.dragOffsetX = player.x - p.x;
    player.targetX = p.x + player.dragOffsetX;
    e.preventDefault?.();
  }

  function onMove(e) {
    if (!state.running || !player.dragging) return;
    const p = pointerPos(e);
    player.targetX = p.x + player.dragOffsetX;
    e.preventDefault?.();
  }

  function onUp() { player.dragging = false; }

  window.addEventListener('mousedown', onDown);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
  window.addEventListener('touchstart', onDown, { passive: false });
  window.addEventListener('touchmove', onMove, { passive: false });
  window.addEventListener('touchend', onUp, { passive: true });
  window.addEventListener('touchcancel', onUp, { passive: true });

  // --- drawing ---
  function drawRoad(r) {
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#1f5f2a';
    ctx.fillRect(0, 0, r.x, H);
    ctx.fillRect(r.x + r.w, 0, W - (r.x + r.w), H);

    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(r.x, r.y, r.w, r.h);

    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(r.x, 0); ctx.lineTo(r.x, H);
    ctx.moveTo(r.x + r.w, 0); ctx.lineTo(r.x + r.w, H);
    ctx.stroke();

    const laneW = r.w / 3;
    ctx.strokeStyle = 'rgba(255,255,255,0.33)';
    ctx.lineWidth = 5;
    ctx.setLineDash([22, 18]);
    ctx.beginPath();
    ctx.moveTo(r.x + laneW, 0); ctx.lineTo(r.x + laneW, H);
    ctx.moveTo(r.x + laneW*2, 0); ctx.lineTo(r.x + laneW*2, H);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    for (const s of stripes) {
      ctx.fillRect(r.x + r.w*0.5 - 6, s.y, 12, s.h);
    }
  }

  function drawCone(o) {
    ctx.save();
    ctx.translate(o.x, o.y);

    ctx.fillStyle = '#ff8a00';
    ctx.beginPath();
    ctx.moveTo(0, -o.r);
    ctx.lineTo(-o.r*0.85, o.r);
    ctx.lineTo(o.r*0.85, o.r);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(-o.r*0.8, o.r*0.55, o.r*1.6, o.r*0.35);

    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillRect(-o.r*0.45, 0, o.r*0.9, o.r*0.22);

    ctx.restore();
  }

  function drawBoost(o, t) {
    const pulse = 1 + 0.10*Math.sin(t*6 + o.phase);
    const s = o.r * pulse;

    ctx.save();
    ctx.translate(o.x, o.y);

    ctx.fillStyle = 'rgba(255, 212, 0, 0.18)';
    ctx.beginPath();
    ctx.arc(0, 0, s*1.25, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#ffd400';
    ctx.beginPath();
    ctx.moveTo(-s*0.15, -s*1.05);
    ctx.lineTo( s*0.25, -s*0.20);
    ctx.lineTo( s*0.00, -s*0.20);
    ctx.lineTo( s*0.35,  s*1.05);
    ctx.lineTo(-s*0.35,  s*0.10);
    ctx.lineTo(-s*0.05,  s*0.10);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.restore();
  }

  function drawFinishLine(r) {
    const y = state.finishY;
    const tile = 22;
    const cols = Math.ceil(r.w / tile);
    const rows = 2;

    ctx.save();
    ctx.translate(r.x, y);
    for (let row=0; row<rows; row++) {
      for (let col=0; col<cols; col++) {
        const isWhite = (row + col) % 2 === 0;
        ctx.fillStyle = isWhite ? 'rgba(255,255,255,0.95)' : 'rgba(0,0,0,0.95)';
        ctx.fillRect(col*tile, row*tile, tile, tile);
      }
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, cols*tile, rows*tile);
    ctx.restore();
  }

  function drawSpriteCentered(img, x, y, w, h, wobble=0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(wobble);

    if (img) {
      const scale = Math.min(w / img.width, h / img.height);
      const dw = img.width * scale;
      const dh = img.height * scale;
      ctx.drawImage(img, -dw/2, -dh/2, dw, dh);
    } else {
      ctx.fillStyle = '#e33';
      ctx.fillRect(-w/2, -h/2, w, h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(-w*0.18, -h*0.35, w*0.36, h*0.2);
    }

    ctx.restore();
  }

  // IMPORTANT: update rival.x before collision checks
  function updateRivalX() {
    const centers = laneCenters();
    rival.x = centers[rival.lane] + Math.sin(state.t*1.5) * 6;
  }

  function fmtTime(seconds) {
    const s = Math.max(0, Math.ceil(seconds));
    const m = Math.floor(s / 60);
    const r = s % 60;
    return `${m}:${String(r).padStart(2, '0')}`;
  }

  function drawHUD() {
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.font = '800 22px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(`MPH: ${Math.round(state.mph)}`, 14, 30);

    if (state.mode === MODE.RACE) {
      const barX = 14, barY = 44, barW = 220, barH = 14;
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.fillRect(barX, barY, barW, barH);

      const pct = clamp(state.mph / MPH_GOAL, 0, 1);
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.fillRect(barX, barY, barW * pct, barH);

      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barW, barH);

      ctx.font = '650 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.72)';
      ctx.fillText(`Goal: ${MPH_GOAL}`, barX + barW + 10, barY + 12);

      if (state.finishActive && !state.finishCrossed) {
        ctx.fillStyle = 'rgba(255,255,255,0.80)';
        ctx.font = '800 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText(`FINISH LINE!`, 14, 76);
      }
    } else {
      ctx.font = '800 18px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillText(`TIME: ${fmtTime(state.timeLeft)}`, 14, 56);

      ctx.font = '650 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.72)';
      ctx.fillText(`Top: ${Math.round(state.topMph)} MPH`, 14, 76);
    }
  }

  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr) {
    const px = Math.max(rx, Math.min(cx, rx + rw));
    const py = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - px;
    const dy = cy - py;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function rectRectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function drawCars(wob) {
    if (state.mode === MODE.RACE && rival.active) {
      drawSpriteCentered(car2OK ? car2 : null, rival.x, rival.y, rival.w, rival.h, wob * 0.35);
    }
    // Player car depends on Garage selection
    const sel = getSelectedCarId();
    const rec = carSprites[sel] || carSprites[GARAGE_CARS[0].id] || null;
    const pImg = (rec && rec.ok) ? rec.img : null;
    drawSpriteCentered(pImg, player.x, player.y, player.w, player.h, wob);
  }

  // --- main loop ---
  function tick(ts) {
    requestAnimationFrame(tick);
    const t = ts / 1000;
    const dt = Math.min(0.033, state.lastT ? (t - state.lastT) : 0.016);
    state.lastT = t;
    state.t = t;

    // When menu/end is up, do NOT draw the track/HUD behind it.
    if (!state.running) {
      ctx.fillStyle = '#0b0b0b';
      ctx.fillRect(0, 0, W, H);
      return;
    }

    if (state.bumpTimer > 0) state.bumpTimer -= dt;
    if (state.shake > 0) state.shake = Math.max(0, state.shake - dt*30);
    if (state.rivalCrashCD > 0) state.rivalCrashCD = Math.max(0, state.rivalCrashCD - dt);

    // time trial countdown
    if (state.mode === MODE.TIME) {
      state.timeLeft -= dt;
      if (state.timeLeft <= 0) {
        sfxPlay('win');
        showEndScreen('Time!', 'Time trial complete.');
        return;
      }
    }

    // mph decay
    if (MPH_DECAY_PER_SEC > 0) setMph(state.mph - MPH_DECAY_PER_SEC * dt);

    // lose if mph hits 0
    if (state.mph <= 0.001) {
      sfxPlay('lose');
      showEndScreen('Oh no!', 'Your speed hit <b>0 MPH</b>.');
      return;
    }

    // rival (race mode only)
    if (state.mode === MODE.RACE && rival.active) {
      const chase = (state.mph - rival.mph) * 0.18;
      const wobble = (Math.sin(t*0.7) * 0.8) + (Math.random()-0.5)*0.35;
      setRivalMph(rival.mph + chase*dt + wobble*dt);

      const rel = rival.mph - state.mph;
      rival.yOffset += (-rel * 0.55) * dt;
      rival.yOffset = clamp(rival.yOffset, -220, 160);
      rival.y = player.y + rival.yOffset;

      updateRivalX(); // keep x current BEFORE object collisions
    }

    // finish trigger (race mode only)
    if (state.mode === MODE.RACE && !state.finishActive && state.mph >= MPH_GOAL) {
      state.finishActive = true;
      state.finishCrossed = false;
      state.finishY = -80;

      setRivalMph(Math.min(rival.mph, clamp(state.mph - (6 + Math.random()*10), 0, MPH_MAX_RACE)));
      rival.yOffset = 70 + Math.random()*60;
      rival.y = player.y + rival.yOffset;
      updateRivalX();
    }

    const scroll = mphToScroll(state.mph, state.mode) * dt;

    // move stripes
    for (const s of stripes) {
      s.y += scroll;
      if (s.y > H + 80) {
        s.y = -80;
        s.h = 30 + Math.random() * 30;
      }
    }

    // spawning
    spawnConeCD -= dt;
    spawnBoostCD -= dt;

    const spdFactor = clamp(state.mph / 60, 0.3, 1.45);
    const boostBias = (state.mode === MODE.TIME) ? 1.25 : 1.0;

    const allowSpawns = (state.mode === MODE.TIME) || (!state.finishActive);
    if (allowSpawns) {
      if (spawnConeCD <= 0) {
        spawn('cone');
        spawnConeCD = (1.15 / spdFactor) + Math.random() * 0.45;
      }
      if (spawnBoostCD <= 0) {
        spawn('boost');
        spawnBoostCD = ((0.90 / spdFactor) + Math.random() * 0.55) / boostBias;
      }
    }

    // update player position + clamp
    const r = roadRect();
    const minX = r.x + player.w * 0.42;
    const maxX = r.x + r.w - player.w * 0.42;
    player.targetX = clamp(player.targetX, minX, maxX);
    player.x += (player.targetX - player.x) * 0.22;

    // edge scrape penalty
    const edgePad = 8;
    const tooLeft = (player.x - player.w*0.5 < r.x + edgePad);
    const tooRight = (player.x + player.w*0.5 > r.x + r.w - edgePad);
    if ((tooLeft || tooRight) && state.bumpTimer <= 0) {
      doBump();
      sfxPlay('bump');
      setMph(state.mph - MPH_EDGE_SCRAPE_LOSS);
    }

    // update objects + collisions for both cars
    for (let i = objs.length - 1; i >= 0; i--) {
      const o = objs[i];
      o.y += scroll;

      // player hitbox
      const prx = player.x - player.w*0.34;
      const pry = player.y - player.h*0.40;
      const prw = player.w*0.68;
      const prh = player.h*0.80;

      if (rectCircleCollide(prx, pry, prw, prh, o.x, o.y, o.r)) {
        if (o.type === 'boost') { setMph(state.mph + MPH_BOOST_GAIN); sfxPlay('boost'); }
        else { doBump(); sfxPlay('cone'); setMph(state.mph - MPH_CONE_LOSS); }
        objs.splice(i, 1);
        continue;
      }

      // rival clears objects too (race mode only)
      if (state.mode === MODE.RACE && rival.active) {
        const rrx = rival.x - rival.w*0.34;
        const rry = rival.y - rival.h*0.40;
        const rrw = rival.w*0.68;
        const rrh = rival.h*0.80;

        if (rectCircleCollide(rrx, rry, rrw, rrh, o.x, o.y, o.r)) {
          if (o.type === 'boost') setRivalMph(rival.mph + MPH_BOOST_GAIN);
          else setRivalMph(rival.mph - MPH_CONE_LOSS);
          objs.splice(i, 1);
          continue;
        }
      }

      if (o.y > H + 120) objs.splice(i, 1);
    }

    // crash into rival consequence (race mode only)
    if (state.mode === MODE.RACE && rival.active && state.rivalCrashCD <= 0) {
      const pax = player.x - player.w*0.34;
      const pay = player.y - player.h*0.40;
      const paw = player.w*0.68;
      const pah = player.h*0.80;

      const rax = rival.x - rival.w*0.34;
      const ray = rival.y - rival.h*0.40;
      const raw = rival.w*0.68;
      const rah = rival.h*0.80;

      if (rectRectCollide(pax, pay, paw, pah, rax, ray, raw, rah)) {
        doBump();
        sfxPlay('bump');
        setMph(state.mph - MPH_RIVAL_CRASH_LOSS_PLAYER);
        setRivalMph(rival.mph - MPH_RIVAL_CRASH_LOSS_RIVAL);

        // separate them to avoid sticking
        if (rival.y <= player.y) rival.yOffset -= 40;
        else rival.yOffset += 40;
        rival.yOffset = clamp(rival.yOffset, -220, 160);
        rival.y = player.y + rival.yOffset;
        updateRivalX();

        state.rivalCrashCD = 0.45;
      }
    }

    // finish line progression + win (race mode only)
    if (state.mode === MODE.RACE && state.finishActive && !state.finishCrossed) {
      state.finishY += scroll;
      if (state.finishY >= player.y - 20) {
        state.finishCrossed = true;
        sfxPlay('win');
        showEndScreen('You Win!', `You reached <b>${MPH_GOAL} MPH</b> and crossed the finish line first.`);
        return;
      }
    }

    // render with shake
    ctx.save();
    if (state.shake > 0) {
      const sx = (Math.random() - 0.5) * state.shake;
      const sy = (Math.random() - 0.5) * state.shake;
      ctx.translate(sx, sy);
    }

    drawRoad(r);

    if (state.mode === MODE.RACE && state.finishActive && !state.finishCrossed) {
      drawFinishLine(r);
    }

    for (const o of objs) {
      if (o.type === 'cone') drawCone(o);
      else drawBoost(o, t);
    }

    const wob = (state.bumpTimer > 0) ? Math.sin(state.t*40) * 0.08 : 0;
    drawCars(wob);
    drawHUD();

    ctx.restore();
  }

  // --- boot ---
  (async () => {
    initAudio();
    maybeShowAudioHint();
    // Load all selectable player cars
    for (const c of GARAGE_CARS) {
      const r = await loadImg(c.sprite);
      carSprites[c.id] = { ok: r.ok, img: r.img };
    }

    // Rival car sprite (unchanged)
    const b = await loadImg('assets/car2.png');
    car2OK = b.ok; car2 = b.img;


    showTitleScreen();
    requestAnimationFrame(tick);
  })();

})();
</script>
</body>
</html>
